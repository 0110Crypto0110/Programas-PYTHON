# -*- coding: utf-8 -*-
"""algoritmos

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dzxx2wKXMQpA8I7s2yelqZgdYCSPcyyY

# Elimicação Gaussiana
"""

def gauss(a, b):
    n = len(b)  # Tamanho do vetor b, que representa o número de equações no sistema
    det = 1  # Inicializa o determinante com 1

    # Iteração sobre as colunas (k) da matriz, exceto a última
    for k in range(n - 1):
        pivo = a[k][k]  # Elemento da diagonal principal, usado como pivô

        # Iteração sobre as linhas (i) abaixo da diagonal principal
        for i in range(k + 1, n):
            m = a[i][k] / pivo  # Fator multiplicador para zerar os elementos abaixo do pivô

            # Iteração sobre as colunas (j) da linha atual (i)
            for j in range(k, n):
                a[i][j] = a[i][j] - m * a[k][j]  # Atualiza os elementos da linha usando o fator multiplicador
            b[i] = b[i] - m * b[k]  # Atualiza os elementos do vetor b

    # Calcula o determinante multiplicando os elementos da diagonal principal
    for k in range(n):
        det *= a[k][k]

    return a, b, det

# Matriz de coeficientes do sistema de equações
a = [[3, 2, 4], [1, 1, 2], [4, 3, -2]]

# Vetor de termos independentes do sistema de equações
b = [1, 2, 3]

# Chama a função gauss e armazena o resultado
resultado = gauss(a, b)

# Imprime o resultado
print("Matriz A após eliminação de Gauss:")
for linha in resultado[0]:
    print(linha)

print("Vetor b após eliminação de Gauss:", resultado[1])
print("Determinante:", resultado[2])

"""# Subistituicao reversa"""

def substituicao_reversa(a, b):
    n = len(b)  # Tamanho do vetor b, que representa o número de equações no sistema
    x = n * [0]  # Inicializa o vetor solução x com zeros

    # Calcula a última solução diretamente
    x[n - 1] = b[n - 1] / a[n - 1][n - 1]

    # Percorre as linhas de baixo para cima
    for k in range(n - 2, -1, -1):
        # Inicializa a variável para acumular as soluções já disponíveis
        s = 0

        # Calcula a soma dos produtos dos coeficientes pelas soluções já conhecidas
        for j in range(k + 1, n):
            s += a[k][j] * x[j]

        # Calcula a solução atual
        x[k] = (b[k] - s) / a[k][k]

    # Retorna o vetor solução x
    return x

# Teste da função substituicao_reversa
at = [[1, 0.5, 0.25], [0, 2, 1.25], [0, 0, 0.5]]
bt = [1, 2, 3]

# Chama a função substituicao_reversa e armazena o resultado
x = substituicao_reversa(at, bt)

# Imprime o vetor solução x
print(x)

"""# Matriz de hilbert"""

import numpy as np

def hilbert(n):
    # Cria a matriz de Hilbert com tamanho n
    h = [[1 / ((i + 1) + (j + 1) - 1) for i in range(n)] for j in range(n)]
    # Calcula o vetor b, que é a soma das linhas da matriz de Hilbert
    b = [sum(linhas) for linhas in h]
    return h, b

# Testando para um valor específico de 3
n = 3
h, b = hilbert(n)
print("Matriz de Hilbert para n =", n)
print(np.array(h))
print("Vetor correspondente b:", b)
print("-")
print("-")
print("-")
# Testando para um valor específico de 10
n = 10
h, b = hilbert(n)
print("Matriz de Hilbert para n =", n)
print(np.array(h))
print("Vetor correspondente b:", b)
print("-")
print("-")
print("-")
# Testando para um valor específico de 100
n = 100
h, b = hilbert(n)
print("Matriz de Hilbert para n =", n)
print(np.array(h))
print("Vetor correspondente b:", b)