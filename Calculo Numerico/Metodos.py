# -*- coding: utf-8 -*-
"""Jr-RelatorioCN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZNzk8dFi86JJ-ofuNt-g-kuVseaPo-f-

# Atividade 02 - Zeros de Funções Reais

Nome completo:Joao Ricardo Justo Lins

Data:

# Introdução

O presente trabalho apresenta o relatório da implementação computacional de diferentes técnicas numéricas estudadas na disciplina de Cálculo Numérico, lecionada às turmas de engenharia da Unidade Acadêmica de Belo Jardim. Utiliza-se a linguagem Python para a implementação dos algoritmos e considera-se a função

$$f(x) = e^x - 2x - 1
$$
"""

import numpy as np

def f(x):
    return np.exp(x) - 2*x - 1

"""# Estudo do sinal da função

A função $f(x) = e^x - 2x - 1$ possui pelo menos uma zero no intervalo $(1,2)$ uma vez que $f(1) = e−3 $, $f(2) = e^
2
 −5$, de modo que a função troca de sinal no intervalo considerado.

Calulando-se a derivada da função obtem-se

$$f'(x) = e^
x
 −2.$$

Verifica-se que $f'(x)>0 \, (ou <0)$ para todo $x\in(a,b)$. Portanto, como a derivada não troca de sinal em $(a,b)$, existe um único zero para $f(x)$ neste intervalo.

O intervalo $(1,2)$ será utilizada para todos os métodos numéricos a serem implementados, a fim de comparação de eficiência entre os métodos.

# Grafico da função
"""

import numpy as np
import matplotlib.pyplot as plt

# Definição da função
def f(x):
    return np.exp(x) - 2*x - 1

# Intervalo de valores de x
x_values = np.linspace(-2, 3, 400)
# Calcula os valores correspondentes de f(x)
y_values = f(x_values)

# Plotagem da função
plt.figure(figsize=(10, 6))
plt.plot(x_values, y_values, label='$f(x) = e^x - 2x - 1$')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Gráfico da função $f(x) = e^x - 2x - 1$')
plt.grid(True)
plt.legend()
plt.show()

# defina o intervalo
a = 1
b = 2

"""Para todos os os métodos a serem implementados e comparados, será considerada a precisão $ɛ=0.00009$ de quatro casas decimais, como segue:"""

# precisão
e = 0.00009

"""# Método da Bissecção

O método da bissecção consistem em dividir iterativamente o intervalo ao meio, refinando progressivamente a busca pela raiz da função até alcançar uma precisão desejada.

"""

import numpy as np
import matplotlib.pyplot as plt

def f(x):
    return np.exp(x) - 2*x - 1

def bissecao(f, a, b, precisao=0.00009, max_iter=100):
    # Verifica se os sinais dos extremos do intervalo são diferentes
    if np.sign(f(a)) == np.sign(f(b)):
        raise ValueError("Os valores de 'a' e 'b' devem ter sinais opostos.")

    x_values = []
    fx_values = []

    iter_count = 0
    while iter_count < max_iter:
        iter_count += 1
        # Calcula o ponto médio do intervalo
        c = (a + b) / 2

        # Armazena os valores de x e f(x) para plotagem
        x_values.append(c)
        fx_values.append(f(c))

        # Verifica se a largura do intervalo é menor que a precisão
        if abs(b - a) < precisao:
            break

        # Atualiza o intervalo com base no sinal de f(c)
        if np.sign(f(c)) == np.sign(f(a)):
            a = c
        else:
            b = c

    return x_values, fx_values, c, iter_count

# Intervalo inicial
a = 1
b = 2

# Aplica o método da bisseção
x_values, fx_values, raiz_aprox, num_iter = bissecao(f, a, b)

# Imprime a raiz aproximada e o número de iterações
print("Raiz aproximada:", raiz_aprox)
print("Número de iterações:", num_iter)

# Valores de x para plotagem
x = np.linspace(a, b, 100)

# Plotagem da função
plt.plot(x, f(x), label='f(x)')
plt.axhline(0, color='black', linewidth=0.5)
plt.grid(True, linestyle='--', linewidth=0.5)

# Plotagem dos pontos iniciais da função em verde
plt.scatter([a, b], [f(a), f(b)], color='green', label='Pontos iniciais')

# Plotagem dos pontos da bisseção
plt.scatter(x_values[:-1], fx_values[:-1], color='red', label='Pontos da bisseção')
# Destaque do último ponto (raiz) em amarelo
plt.scatter(x_values[-1], fx_values[-1], color='yellow', label='Raiz')

plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Método da Bisseção')
plt.legend()
plt.show()

"""# Método da Posição Falsa

O método da posição falsa consiste em O traçar uma reta em pontos definidos pelo intervalo e a função calculada nesse intervalo, ou seja o ponto a (a,f(a)) e o ponto b (b,f(b)); e assim estimar um valor intermediario entre os pontos a e b, afim de reduzir o intervalo (a,b), repetindo o processo.
"""

import numpy as np
import matplotlib.pyplot as plt

def f(x):
    return np.exp(x) - 2*x - 1

def false_position(f, a, b, precisao=0.00009, max_iter=100):
    if f(a) * f(b) > 0:
        raise ValueError("Os valores de 'a' e 'b' devem ter sinais opostos.")

    iter_count = 0
    x_values = []
    fx_values = []
    while iter_count < max_iter:
        iter_count += 1
        c = (a*f(b) - b*f(a)) / (f(b) - f(a))

        if abs(f(c)) < precisao:
            break

        if f(c) * f(a) > 0:
            a = c
        else:
            b = c

        x_values.append(c)
        fx_values.append(f(c))

    return c, iter_count, x_values, fx_values

# Função para interpolação linear
def interpolacao_linear(x0, y0, x1, y1, x):
    return y0 + (y1 - y0) * (x - x0) / (x1 - x0)

# Intervalo inicial
a = 1
b = 2

# Precisão (tolerância)
precisao = 0.00009

# Aplicando o método da posição falsa
raiz, iteracoes, x_values, fx_values = false_position(f, a, b, precisao)

# Exibindo a raiz encontrada e o número de iterações necessárias
print("Raiz encontrada:", raiz)
print("Número de iterações:", iteracoes)

# Plotagem da função, pontos avaliados e interpolações lineares
x = np.linspace(a, b, 100)
y = f(x)

plt.figure(figsize=(10, 6))
plt.plot(x, y, label='$f(x) = e^x - 2x - 1$')
plt.axhline(0, color='black', linewidth=0.5)
plt.scatter(x_values, fx_values, color='yellow', label='Pontos avaliados', zorder=5)

# Adiciona interpolações lineares
for i in range(len(x_values) - 1):
    x_interpolados = np.linspace(x_values[i], x_values[i + 1], 10)
    y_interpolados = interpolacao_linear(x_values[i], fx_values[i], x_values[i + 1], fx_values[i + 1], x_interpolados)
    plt.plot(x_interpolados, y_interpolados, linestyle='--', color='pink', linewidth=1, label='Interpolações lineares' if i == 0 else None)

plt.scatter(raiz, f(raiz), color='red', label='Raiz encontrada', zorder=10)
plt.scatter(a, f(a), color='green', label='Ponto inicial (a, f(a))', zorder=10)
plt.scatter(b, f(b), color='blue', label='Ponto inicial (b, f(b))', zorder=10)
plt.title('Método da Posição Falsa')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""# Método do Ponto Fixo

Claro, aqui está o texto atualizado:

---

O método do ponto fixo consiste em obter uma função de iteração $\phi(x)$ a partir da equação $f(x) = 0$.

Supondo que a função de iteração é convergente, usamos uma condição inicial $x_0 \in (a,b)$ e executamos a rotina
$$x_{k+1} = \phi(x_k)$$ até que $|f(x_k)| < ɛ$, onde $ɛ$ é a precisão indicada.

Para verificar se a função de iteração é convergente, resolvemos a inequação modular
$$ |\phi'(x)| < 1 $$
e verificamos a intersecção do intervalo obtido nesta inequação com o intervalo inicial $(a,b)$. A condição inicial $x_0$ deve estar nessa intersecção.

Para a função dada, obtemos uma função de iteração:
$$
\phi(x) = \frac{{\ln(2x + 1)}}{2}
$$

A inequação modular $|\phi'(x)| < 1$ produz:
$$
\left| \frac{1}{2(2x + 1)} \right| < 1
$$
que resulta no intervalo:
$$
-1 < 2x + 1 < 1 \Rightarrow -2 < 2x < 0 \Rightarrow -1 < x < 0
$$
Portanto, a função de iteração é convergente, pois o intervalo $(-1, 0)$ inclui o intervalo inicial $(a, b) = (1, 2)$, e a condição inicial $x_0$ deve estar nessa intersecção.
"""

import numpy as np
import matplotlib.pyplot as plt

# Definição da função f(x)
def f(x):
    return np.exp(x) - 2*x - 1

# Método do ponto fixo para encontrar a raiz da função
def fixed_point_method(g, x0, precisao=1e-5, max_iter=100):
    x = x0
    iter_count = 0
    iter_values = []  # Lista para armazenar os valores de x em cada iteração
    while iter_count < max_iter:
        x_next = g(x)
        if abs(x_next - x) < precisao:
            break
        x = x_next
        iter_values.append(x)  # Armazena o valor de x na lista
        iter_count += 1
    return x_next, iter_count, iter_values

# Função de iteração para o método do ponto fixo
def g(x):
    return (2*x + 1) / np.exp(x)

# Intervalo (1, 2)
a = 1
b = 2

# Chute inicial para o método do ponto fixo
x0 = 1.5

# Aplicando o método do ponto fixo
raiz, iteracoes, iter_values = fixed_point_method(g, x0)

# Imprime o número de iterações e a raiz aproximada
print("Raiz aproximada:", raiz)
print("Número de iterações:", iteracoes)

# Valores de x para plotagem
x_values = np.linspace(a, b, 100)
# Valores correspondentes de f(x)
y_values = f(x_values)

# Plotagem da função f(x) e dos pontos de iteracao pelo método do ponto fixo
plt.figure(figsize=(10, 6))
plt.plot(x_values, y_values, label='$f(x) = e^x - 2x - 1$', color='blue')
plt.plot(iter_values, f(np.array(iter_values)), 'ko--', label='Iterações')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Método do Ponto Fixo com Iterações')
plt.legend()
plt.grid(True)
plt.show()

# Plotagem da função f(x) e do ponto de convergência pelo método do ponto fixo
plt.figure(figsize=(10, 6))
plt.plot(x_values, y_values, label='$f(x) = e^x - 2x - 1$', color='blue')
plt.scatter(raiz, f(raiz), color='red', label='Ponto de convergência (Ponto Fixo)')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Método do Ponto Fixo com Iterações')
plt.legend()
plt.grid(True)
plt.show()

"""# Método de Newton

O método de Newton é um caso especial do método do ponto fixo que consiste em usar a função de iteração
$$
\phi(x_k) = x_k - \dfrac{f(x_k)}{f'(x_k)}
$$
Este método é convergente se $f'(x) \neq 0$ e $f''(x)$ existir e for contínua em $(a,b)$. Verificando, observamos que
$$
f'(x) = e^x - 2
$$
Além disso,
$$
f''(x) = e^x
$$
"""

import numpy as np
import matplotlib.pyplot as plt

# Definição da função f(x) e sua derivada f'(x)
def f(x):
    return np.exp(x) - 2*x - 1

def f_prime(x):
    return np.exp(x) - 2

# Método de Newton para encontrar a raiz da função
def newton_method(f, f_prime, x0, precisao=1e-5, max_iter=100):
    x = x0
    iter_count = 0
    iter_values = []  # Lista para armazenar os valores de x em cada iteração
    while iter_count < max_iter:
        x_next = x - f(x) / f_prime(x)
        if abs(x_next - x) < precisao:
            break
        x = x_next
        iter_values.append(x)  # Armazena o valor de x na lista
        iter_count += 1
    return x_next, iter_count, iter_values

# Intervalo (1, 2)
a = 1
b = 2

# Chute inicial para o método de Newton
x0 = 1.5

# Aplicando o método de Newton
raiz, iteracoes, iter_values = newton_method(f, f_prime, x0)

# Imprime o número de iterações e a raiz aproximada
print("Raiz aproximada:", raiz)
print("Número de iterações:", iteracoes)

# Valores de x para plotagem
x_values = np.linspace(a, b, 100)
# Valores correspondentes de f(x)
y_values = f(x_values)

# Plotagem da função f(x) e do ponto de convergência pelo método de Newton
plt.figure(figsize=(10, 6))
plt.plot(x_values, y_values, label='$f(x) = e^x - 2x - 1$', color='blue')
plt.scatter(raiz, f(raiz), color='red', label='Ponto de convergência (Newton)')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Método de Newton com Iterações')
plt.legend()
plt.grid(True)
plt.show()

# Plotagem da função f(x) e dos pontos de iteracao  pelo método de Newton
plt.figure(figsize=(10, 6))
plt.plot(x_values, y_values, label='$f(x) = e^x - 2x - 1$', color='blue')
plt.plot(iter_values, f(np.array(iter_values)), 'ko--', label='Iterações')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Método de Newton com Iterações')
plt.legend()
plt.grid(True)
plt.show()

"""# Método da Secante

O método da secante é uma discretização do método de Newton, no qual a derivada é aproximada por uma diferença finita.

Desta forma, as iterações são calculadas por
$$
x_{k+1} = \dfrac{x_{k-1}\cdot f(x_k) - x_k\cdot f(x_{k-1})}{f(x_k) - f(x_{k-1})}
$$


Assim, são necessárias duas condições iniciais em $(a,b)$.
"""

import numpy as np
import matplotlib.pyplot as plt

# Definição da função f(x)
def f(x):
    return np.exp(x) - 2*x - 1

# Método da secante para encontrar a raiz da função
def secant_method(f, x0, x1, precisao=1e-5, max_iter=100):
    iter_count = 0
    iter_values = []  # Lista para armazenar os valores de x em cada iteração
    while iter_count < max_iter:
        # Calcula o próximo ponto usando a fórmula da secante
        x_next = x1 - f(x1) * (x1 - x0) / (f(x1) - f(x0))
        # Verifica se atingiu a precisão desejada
        if abs(x_next - x1) < precisao:
            break
        # Atualiza os pontos para a próxima iteração
        x0, x1 = x1, x_next
        iter_values.append(x_next)  # Armazena o valor de x na lista
        iter_count += 1
    return x_next, iter_count, iter_values

# Intervalo (1, 2)
a = 1
b = 2

# Chutes iniciais para o método da secante
x0 = 1.5
x1 = 1.7

# Aplicando o método da secante
raiz, iteracoes, iter_values = secant_method(f, x0, x1)

# Imprime o número de iterações e a raiz aproximada
print("Raiz aproximada:", raiz)
print("Número de iterações:", iteracoes)

# Valores de x para plotagem
x_values = np.linspace(a, b, 100)
# Valores correspondentes de f(x)
y_values = f(x_values)

# Plotagem da função f(x) e da raiz pelo método da secante
plt.figure(figsize=(10, 6))
plt.plot(x_values, y_values, label='$f(x) = e^x - 2x - 1$', color='blue')
plt.scatter(iter_values, f(np.array(iter_values)), color='orange', label='Iterações')
plt.scatter(raiz, f(raiz), color='red', label='Ponto de convergência (Secante)')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Método da Secante com Iterações')
plt.legend()
plt.grid(True)
plt.show()

"""# Resultados e Discussões

Dentre os resultados obtidos, verificou-se que o método  de newton executou em menas iterações que os demais; tamebem que as melhores aproximacoes foram as do metodo de newton e do metodo da secante.

 tabela a seguir:


<table>
  <thead>
    <tr>
      <th>Método</th>
      <th>Raiz</th>
      <th>Número de Iterações</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Bissecção</td>
      <td>1.256439208984375</td>
      <td>15</td>
    </tr>
    <tr>
      <td>Ponto Falso</td>
      <td>1.2563871094482981</td>
      <td>14</td>
    </tr>
    <tr>
      <td>Ponto Fixo</td>
      <td>1.0750608711074991</td>
      <td>12</td>
    </tr>
    <tr>
      <td>Método de Newton</td>
      <td>1.2564312087001142</td>
      <td>3</td>
    </tr>
    <tr>
      <td>Método da Secante</td>
      <td>1.2564312086491598</td>
      <td>5</td>
    </tr>
  </tbody>
</table>


"""